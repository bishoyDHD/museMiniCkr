#include <Det_LumiGEM.h>
#include "TStyle.h"

#include<iostream>
#include<cmath>
#include <unistd.h>
#include <fstream>
#include <sstream>
#include <string>
#include<stdio.h> 

// Event display files
#include "TGeoManager.h"
#include "TGeoVolume.h"
#include "TProfile.h"

// Root
#include <math.h>
#include "TF1.h"
#include "TGraph.h"
#include "TH1.h"
#include "TMath.h"

#include "TAxis.h"
#include "TGraph.h"
#include "TMultiGraph.h"
#include "TCanvas.h"
#include "TApplication.h"
#include "TStyle.h"
#include "TPad.h"
#include "TROOT.h"
#include "TColor.h"
#include "TFrame.h"
#include "TVirtualPad.h"

using namespace std;



Det_LumiGEM::Det_LumiGEM(TTree *in, TTree *out, TFile *inf_, TFile *outf_, TObject *p)
  : Plugin(in, out, inf_, outf_, p)
{
  cout << "LumiGEM: Plugin constructor called" << endl;

  verbose=0;

  // generate six cGEM objects to build two telescopes:
  for (int t=0; t<2; t++)  // two telescopes
    for (int i=0; i<3; i++)// three GEMs per telescope
      {
	GEM[t][i] = new cGEM(4); // our GEMs have 4 APVs each
	rmshisto[t][i] = NULL;
      };

  // some hard-coded defaults for the configuration:
  valLMGaussFilterSigma = 1.5;
  valLMMinimumAmplitude =  25;
  valLMMinimumDistance  =   5;
  valLMMaximumNLM       =  10;
  valCFMinimumAmplitude = 100;
  valCFSigmaMin         = 0.4;
  valCFSigmaMax         = 1.5;
  valmake1dhits         =   0;
  valrepairbrokenstrips =   1;
  // triggerpatternOI      = 0x4;
  valAPVsyncDataRangeLow      = -65535;
  valAPVsyncDataRangeHigh     = +65535;
  valAPVoutOfSyncSampleThreshold   = 0;
  valAPVoutOfSyncEventThreshold    = 1;
  valAPVzeroSamplesEventThreshold  = 1;

  // Not event display mode by default
  vis = false;

  // trigger pattern of interest: by default we're interested in anything:
  triggerpatternOI = 0xff;

  // slowcontrol lumi info not yet connected:
  //  SClumi = NULL;
  // eventinfo branch not yet connected:
  // eventinfo = NULL;

  // Detector status undefined at the beginning:
  ProcessDetectorFlagOnly = false;
  DetectorStatus = LumiGEM::unknown;
  WriteDetectorFlagFilename[0]=0;

  LumiGUI = new Tab_LumiGEM();

  for (int i=0;i<250*3*2*2;i++)
    perchannelped[i]=0;

  someSpecHist=false;
  allSpecHist=false;
}

Det_LumiGEM::~Det_LumiGEM()
{
}


Long_t Det_LumiGEM::defineHistograms()
{
  printf(" Det_LumiGEM::defineHistograms() called\n");
  InitRMShistos();
  // x vs x and y vs y histograms (mapping check):
  int nbins_vs=64;
  for (int t=0; t<2; t++)
    for (int i=0; i<3; i++)
      {
	H_hitmap2d[t][i] = dH2(Form("MUSEtele/%s/%s_hitmap",leftright[t], GEMname[i]),
			       Form("%s %s GEM hitmap", leftright[t], GEMname[i]),
			       250, -0.5, 249.5, 250, -0.5, 249.5);

	for (int j=0; j<3; j++)
	  {
	    H_XvsX[t][i][j]=NULL;
	    H_YvsY[t][i][j]=NULL;
	    if (i==j) continue;
	    H_XvsX[t][i][j] = dH2(Form("MUSEtele/%s/%sx_vs_%sx", leftright[t], GEMname[i], GEMname[j]),
				  Form("%s %s x vs. %s x", leftright[t], GEMname[i], GEMname[j]),
				  nbins_vs, -0.5, 249.5, nbins_vs, -0.5, 249.5);
	    printf("    [%d][%d][%d] %p\n", t, i, j, H_XvsX[t][i][j]);
	    H_YvsY[t][i][j] = dH2(Form("MUSEtele/%s/%sy_vs_%sy", leftright[t], GEMname[i], GEMname[j]),
				  Form("%s %s y vs. %s y", leftright[t], GEMname[i], GEMname[j]),
				  nbins_vs, -0.5, 249.5, nbins_vs, -0.5, 249.5);
	    printf("    [%d][%d][%d] %p\n", t, i, j, H_YvsY[t][i][j]);
	  };

      };
  //LumiGUI->defineHistograms();
 


  return 0;
}

Long_t Det_LumiGEM::defineHistogramsSpec()
{
  someSpecHist=true;
  for (int t=0; t<2; t++)
    for (int i=0; i<3; i++)
      {
	deadchmap[t][i]=dH2(Form("MUSEtele/%s/%s/deadchmap%s",leftright[t],GEMname[i],GEMname[i]), Form("%d GEM Dead Channel Map",i), 250, -0.5, 249.5,250, -0.5, 249.5);
	// cmode related................ 
	h1adcspec_cmode_x_apv1[t][i]=dH1(Form("MUSEtele/%s/%s/getmean_cmode_x_apv1",leftright[t],GEMname[i]), Form("%d GEM X APV 1 - peak excluded average ADCs for many events",i),100,0.0,3000.0);
	h1adcspec_cmode_y_apv1[t][i]=dH1(Form("MUSEtele/%s/%s/getmean_cmode_y_apv1",leftright[t],GEMname[i]), Form("%d GEM Y APV 1- peak excluded average ADCs for many events",i),100,0.0,3000.0);
	h1adcspec_cmode_x_apv2[t][i]=dH1(Form("MUSEtele/%s/%s/getmean_cmode_x_apv2",leftright[t],GEMname[i]), Form("%d GEM X APV 2- peak excluded average ADCs for many events",i),100,0.0,3000.0);
	h1adcspec_cmode_y_apv2[t][i]=dH1(Form("MUSEtele/%s/%s/getmean_cmode_y_apv2",leftright[t],GEMname[i]), Form("%d GEM Y APV 2- peak excluded average ADCs for many events",i),100,0.0,3000.0);

	//cmode and pedestal subtraction related
	h2adcspec_cmode_nopk_x[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_cmode_nopk_x",leftright[t],GEMname[i]), Form("%d GEM X APV ADCs - nopk (excluding peak)-c mode subtracted",i), 250,-0.5, 249.5,4096,-500.5,3595.5);
	h2adcspec_cmode_nopk_y[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_cmode_nopk_y",leftright[t],GEMname[i]), Form("%d GEM Y APV ADCs - nopk (excluding peak)-c mode subtracted",i), 250,-0.5, 249.5,4096,-500.5,3595.5);

	h2adcspec_cm_pedsub_nopk_x[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_cm_pedsub_nopk_x",leftright[t],GEMname[i]), Form("%d GEM X APV ADCs after both cm and ped subtraction (excluding peak)",i), 250,-0.5, 249.5,4096,-500.5,3595.5);
	h2adcspec_cm_pedsub_nopk_y[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_cm_pedsub_nopk_y",leftright[t],GEMname[i]), Form("%d GEM Y APV ADCs after both cm and ped subtraction (excluding peak)",i), 250,-0.5, 249.5,4096,-500.5,3595.5);
    
	h2adcspec_cm_pedsub_peak_x[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_cm_pedsub_peak_x",leftright[t],GEMname[i]), Form("%d GEM X APV Signal ADCs after both cm and ped subtraction",i), 250,-0.5, 249.5,4096,-595.5,3500.5);
	h2adcspec_cm_pedsub_peak_y[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_cm_pedsub_peak_y",leftright[t],GEMname[i]), Form("%d GEM Y APV Signal ADCs after both cm and ped subtraction",i), 250,-0.5, 249.5,4096,-595.5,3500.5);
	
      };
  return ok;
}


Long_t Det_LumiGEM::defineHistogramsSpecAll()
{
  allSpecHist=true;
  defineHistogramsSpec();
  for (int t=0; t<2; t++)
    for (int i=0; i<3; i++)
      {
	h2maxxADCb4cm[t][i]=dH2(Form("MUSEtele/%s/%s/maxadc_b4cmsub_x",leftright[t],GEMname[i]), Form("%d GEM X APV - maximum ADC (before cmode subtraction)",i), 250, 0.0, 250.0,100,0.0,3000.0);
	h2maxyADCb4cm[t][i]=dH2(Form("MUSEtele/%s/%s/maxadc_b4cmsub_y",leftright[t],GEMname[i]), Form("%d GEM Y APV - maximum ADC (before cmode subtraction)",i), 250, 0.0, 250.0,100,0.0,3000.0);
	h2maxxADCcm[t][i]=dH2(Form("MUSEtele/%s/%s/maxadc_aftcmsub_x",leftright[t],GEMname[i]), Form("%d GEM X APV - maximum ADC (after cmode subtraction)",i), 250, 0.0, 250.0,100,0.0,3000.0);
	h2maxyADCcm[t][i]=dH2(Form("MUSEtele/%s/%s/maxadc_aftcmsub_y",leftright[t],GEMname[i]), Form("%d GEM Y APV - maximum ADC (after cmode subtraction)",i), 250, 0.0, 250.0,100,0.0,3000.0);
	h2maxxADCcmped[t][i]=dH2(Form("MUSEtele/%s/%s/maxadc_aftcmpedsub_x",leftright[t],GEMname[i]), Form("%d GEM X APV - maximum ADC (after both cmode and ped subtraction)",i), 250, 0.0, 250.0,100,0.0,3000.0);
	h2maxyADCcmped[t][i]=dH2(Form("MUSEtele/%s/%s/maxadc_aftcmpedsub_y",leftright[t],GEMname[i]), Form("%d GEM Y APV - maximum ADC (after both cmode and ped subtraction)",i), 250, 0.0, 250.0,100,0.0,3000.0);
	
	h2adcspec_x[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_x",leftright[t],GEMname[i]), Form("%d GEM X APV ADCs",i), 250,-0.5, 249.5,4096,-0.5,4095.5); 
	h2adcspec_y[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_y",leftright[t],GEMname[i]), Form("%d GEM Y APV ADCs",i), 250,-0.5, 249.5,4096,-0.5,4095.5); 
	h2adcspec_nopk_x[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_nopk_x",leftright[t],GEMname[i]), Form("%d GEM X APV ADCs - nopk (excluding peak)",i), 250,-0.5, 249.5,4096,-0.5,4095.5);
	h2adcspec_nopk_y[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_nopk_y",leftright[t],GEMname[i]), Form("%d GEM Y APV ADCs - nopk (excluding peak)",i), 250,-0.5, 249.5,4096,-0.5,4095.5);
	h2evespec_nopk_x[t][i]=dH2(Form("MUSEtele/%s/%s/evespectra_nopk_x",leftright[t],GEMname[i]), Form("%d GEM X APV entries - nopk (excluding peak)",i), 250,-0.5, 249.5,100,0.0,100000);
	h2evespec_nopk_y[t][i]=dH2(Form("MUSEtele/%s/%s/evespectra_nopk_y",leftright[t],GEMname[i]), Form("%d GEM Y APV entries - nopk (excluding peak)",i), 250,-0.5, 249.5,100,0.0,100000);
	
	//cmode and pedestal subtraction related
	h2adcspec_cmode_x[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_cmode_x",leftright[t],GEMname[i]), Form("%d GEM X APV ADCs - c mode subtracted",i), 250,-0.5, 249.5,4096,-595.5,3500.5);
	h2adcspec_cmode_y[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_cmode_y",leftright[t],GEMname[i]), Form("%d GEM Y APV ADCs - c mode subtracted",i), 250,-0.5, 249.5,4096,-595.5,3500.5);
	h2adcspec_cm_pedsub_x[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_cm_pedsub_x",leftright[t],GEMname[i]), Form("%d GEM X APV ADCs after both cm and ped subtraction",i), 250,-0.5, 249.5,4096,-595.5,3500.5);
	h2adcspec_cm_pedsub_y[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_cm_pedsub_y",leftright[t],GEMname[i]), Form("%d GEM Y APV ADCs after both cm and ped subtraction",i), 250,-0.5, 249.5,4096,-595.5,3500.5);

	// hit amplitude related
	H_amplmap2d[t][i]=dH2(Form("MUSEtele/%s/%s/amplmaps%s_aftclust",leftright[t],GEMname[i],GEMname[i]), Form("%d GEM Amplitude Map",i), 250, -0.5, 249.5,250, -0.5, 249.5);
	h2hitmaps[t][i]=dH2(Form("MUSEtele/%s/%s/hitmaps%s_b4clust",leftright[t],GEMname[i],GEMname[i]), Form("%d GEM Hit Map - Before cluster finds",i), 250, -0.5, 249.5,250, -0.5, 249.5);
	H_hitampx[t][i]=dH1(Form("MUSEtele/%s/%s/xhitamps%s_b4clust",leftright[t],GEMname[i],GEMname[i]), Form("%d GEM X Hit Amplitudes - Before cluster finds",i), 100, -500.0, 2500);
	H_hitampy[t][i]=dH1(Form("MUSEtele/%s/%s/yhitamps%s_b4clust",leftright[t],GEMname[i],GEMname[i]), Form("%d GEM Y Hit Amplitudes - Before cluster finds",i), 100, -500.0, 2500);
	h2amplmapsx[t][i]=dH2(Form("MUSEtele/%s/%s/h2amplmapsx%s_b4clust",leftright[t],GEMname[i],GEMname[i]), Form("%d GEM X Amplitude Map - Before cluster finds",i), 250, -0.5, 249.5,250, -0.5, 249.5);
	h2amplmapsy[t][i]=dH2(Form("MUSEtele/%s/%s/h2amplmapsy%s_b4clust",leftright[t],GEMname[i],GEMname[i]), Form("%d GEM Y Amplitude Map - Before cluster finds",i), 250, -0.5, 249.5,250, -0.5, 249.5);
	totentries[t][i]=dH1(Form("MUSEtele/%s/%s/totentries%s_b4clust",leftright[t],GEMname[i],GEMname[i]), Form("%d GEM Total Entries - Before cluster finds",i), 250, -0.5, 249.5);

	if (onlybin2binsub){
	  h2adcspec_pedsub_nopk_x[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_pedsub_nopk_x",leftright[t],GEMname[i]), Form("%d GEM X APV ADCs only ped subtraction (excluding peak)",i), 250,-0.5, 249.5,4096,-500.5,3595.5);
	  h2adcspec_pedsub_nopk_y[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_pedsub_nopk_y",leftright[t],GEMname[i]), Form("%d GEM Y APV ADCs only ped subtraction (excluding peak)",i), 250,-0.5, 249.5,4096,-500.5,3595.5);
	};

	if (doSubtractbaseline){
	  h2adcspec_base_x[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_base_x",leftright[t],GEMname[i]), Form("%d GEM X APV ADCs - baseline subtracted",i), 250,-0.5, 249.5,4096,-595.5,3500.5);
	  h2adcspec_base_y[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_base_y",leftright[t],GEMname[i]), Form("%d GEM Y APV ADCs - baseline subtracted",i), 250,-0.5, 249.5,4096,-595.5,3500.5);
	  h2adcspec_base_nopk_x[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_base_nopk_x",leftright[t],GEMname[i]), Form("%d GEM X APV ADCs - baseline subtracted (excluding peak)",i), 250,-0.5, 249.5,4096,-595.5,3500.5);
	  h2adcspec_base_nopk_y[t][i]=dH2(Form("MUSEtele/%s/%s/adcspectra_base_nopk_y",leftright[t],GEMname[i]), Form("%d GEM Y APV ADCs - baseline subtracted (excluding peak)",i), 250,-0.5, 249.5,4096,-595.5,3500.5);
	};

      }
    return ok;
}


void Det_LumiGEM::InitHitFinder()
{
  hitfinder = new cHitFinder(250, 250);
  hitfinder->SetClusterSigmaRange(valCFSigmaMin, valCFSigmaMax);
  // allocate memory for processed and raw data (for one GEM at a time only):
  xdat    = new int[256];
  ydat    = new int[256];
  xdatraw = new int[256];
  ydatraw = new int[256];
}

////////////////////////////////////////////////////////////////////////////////////////////////

std::vector <int> dattotx(250,0);
std::vector <int> dattoty(250,0);
std::vector <std::vector <int> > dattotx_nopk_ent(3,dattoty);
std::vector <std::vector <int> > dattoty_nopk_ent(3,dattoty);

std::vector <std::vector <int> > gettotpedx(3,dattotx);
std::vector <std::vector <int> > gettotpedy(3,dattoty);
std::vector <std::vector <int> > gettotpedxentries(3,dattotx);
std::vector <std::vector <int> > gettotpedyentries(3,dattoty);

std::vector <std::vector <int> > gettotx_adc(3,dattotx);
std::vector <std::vector <int> > gettoty_adc(3,dattotx);
std::vector <std::vector <int> > gettotx_adc_e(3,dattotx);
std::vector <std::vector <int> > gettoty_adc_e(3,dattotx);
std::vector <std::vector <int> > totent(3,dattoty);

int totampx[2][3][250];
int totampy[2][3][250];
int totampentx[2][3][250];
int totampenty[2][3][250];

//std::vector <std::vector <int> > avgampx(3,dattotx);

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

// Startup function for event display (currently not in use)
Long_t Det_LumiGEM::startup_vis()
{
  vis = true; // Flag that this is event display mode
  startup(); // Call the usual startup
  return ok;
}


Long_t Det_LumiGEM::startup()
{ 
  cout << "LumiGEM: Startup called" << endl;
  // get the SiPM TDC/ADC output tree:
 
  InitSC();
  InitLumiBranches_in();
  InitLumiBranches_out();
  
  //  getBranchObject("EventInfo", (TObject**)&eventinfo);
  runinfo = (MRTRunInfo*)getFileObject("RunInfo");

  // printf("*** eventinfo is %p\n", eventinfo);
  printf("*** runinfo is %p\n", runinfo);

  runstarttime   = runinfo->startTime;
  runstoptime    = runinfo->stopTime;
  nextsctime     = runstarttime+1.0;
  beamcharge     = 0.;
  estlumicounter = 0.;

  blobreader = new cLumiGEMBinaryBlobRead();

  InitHitFinder();

  tmpdat = new int[1024];

  // Do any initializations, e.g. creating histograms, that need the
  // ROOT files already opened:
  //InitRMShistos();

  // print some config information:
  ShowBasicConfig();

  // In case we're called from within the Visual Cooker (visco), we should
  // try to add a tab here:
  viscotab    = addTab("LumiGEM");
  if (viscotab && !vis)
    {
      //gStyle->SetOptStat(1111001);
      printf("LumiGEM: ** VisCo mode **\n");
      LumiGUI->InitGUI(this, viscotab);
      LumiGUI->defineHistograms();
    }
  else if (vis)
    {
      printf("LumiGEM: ** Event Display mode **\n");
      LumiGUI->InitGUI(this, viscotab);
      LumiGUI->defineHistograms();
    }
  else
    printf("LumiGEM: ** non-VisCo mode **\n");

  // count triggers:
  lumitriggercounter[0] = 0;
  lumitriggercounter[1] = 1;
  lumibankcounter[0] = 0;
  lumibankcounter[1] = 0;

  dead_ch_masking=true;/// Keep this always "true" if you want to mask the dead channels defined in /init/LumiGEM.xml file.
  use_gainmatch=false;  /// Keep this always "true" if you want to use channel-to-channel gain match for all APV channels.

  doFindClusters=true;
  doSubtractped=true;
  doSubtractcmode=true;
  doAPVcalib=false;
  doSubtractbaseline=false;
  onlybin2binsub=false;

 //////////////////////////////////Read the common mode mean values at startup/////////////////////////////////////
  std::ifstream cmfile("event_avg_cmode.dat");
  std::string line;
  int tel,gem;
  double avgx_cmode_apv1,avgx_cmode_apv2,avgy_cmode_apv1,avgy_cmode_apv2;
  while (std::getline(cmfile, line)) 
    {
      std::istringstream ss(line);
      ss >> tel>>gem >> avgx_cmode_apv1>> avgx_cmode_apv2 >> avgy_cmode_apv1>> avgy_cmode_apv2;
      cmode_mean_x_apv1[tel][gem]=avgx_cmode_apv1;
      cmode_mean_y_apv1[tel][gem]=avgy_cmode_apv1;
      cmode_mean_x_apv2[tel][gem]=avgx_cmode_apv2;
      cmode_mean_y_apv2[tel][gem]=avgy_cmode_apv2;
       printf("read mean cmode at startup %d %d %5.2lf %5.2lf %5.2lf %5.2lf\n ",tel,gem,cmode_mean_x_apv1[tel][gem],cmode_mean_x_apv2[tel][gem],cmode_mean_y_apv1[tel][gem],cmode_mean_y_apv2[tel][gem]);
    };
  cmfile.close();
  ////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////Read the average pedestal values at startup/////////////////////////////////////
  std::ifstream pedfile("bin_2_bin_pedestals.dat");
  std::string pedline;
  int pedgem,pedstrip;
  double pedx,pedy;
  while (std::getline(pedfile, pedline)) 
    {
      std::istringstream pss(pedline);
      pss >> pedgem >> pedstrip >>pedx >> pedy;
      avg_ped_x[pedgem][pedstrip]=pedx;
      avg_ped_y[pedgem][pedstrip]=pedy;
      //  printf("read average ped at startup %d %d %d %d\n ",pedgem,pedstrip,avg_ped_x[pedgem][pedstrip],avg_ped_y[pedgem][pedstrip]);
    };
  pedfile.close();

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////////////////////////

  return ok;
}


Long_t Det_LumiGEM::startup_cmode()
{
  startup();
  //  getmeancmode=true;
  // disable subtracting existing cmode
  doSubtractcmode=false;
  // disable subtracting existing pedestals
  doSubtractped=false;
 // disable subtracting the baseline
 doSubtractbaseline=false;
  // disable the slow stuff
  doFindClusters=false;
  return ok;
}

Long_t Det_LumiGEM::startup_findPedestal()
{
  startup();
 // disable subtracting cmode, ONLY if you want to check the bin-2-bin pedestal effects alone.//////////////////
 doSubtractcmode=true;
  // disable subtracting existing pedestals
  doSubtractped=false;
 // disable subtracting the baseline
 doSubtractbaseline=false;
  // disable the slow stuff
  doFindClusters=false;
  return ok;
}

Long_t Det_LumiGEM::startup_APVcalib()
{
  startup();
  doAPVcalib=true; // Only to do the APV gain calibration
  use_gainmatch=false; // Use APV gain maching, TRUE only if you want to check your calib constants. Otherwise always FALSE here
 // Use common mode subtraction
 doSubtractcmode=true;
  // Use pedestal subtraction
  doSubtractped=true;
 // disable the baseline subtraction (the polynomial fit method)
 doSubtractbaseline=false;
  // disable the cluster finding
  doFindClusters=false;
  return ok;
}

int Det_LumiGEM::ReadTelescopeData(int t)
{
  int cnt=0;

  if (blobreader->ReadBank(LUMI[t])==0)
    return 0;
  if (verbose>1)
    printf(" bank LUMI[%d] has %d APVs\n", t, blobreader->GetNAPVs());
  for (int i=0; i<3; i++)// three GEMs per telescope
    {
      int napvs = blobreader->GetNAPVs();
      for (int apv=0; apv<napvs; apv++)
	cnt += GEM[t][i]->AddAPVData(apv, blobreader->GetBankBuffer(apv));
    };

  return cnt;
};

int Det_LumiGEM::CheckRange(int n, int *dat, int low, int high)
// Returns the number of samples in 'dat' outside range [low,high]
//  Return values:
//     0:  everything inside range
//    >0:  number of samples outside range
//    -1:  everything inside range AND all samples are equal to zero! (missing data?)
{
  // counter for number of events outside range; flag to signal if all samples are =0
  int cnt=0, nullflag=1;
  for (int i=0; i<n; i++)
    if ((dat[i]<low)||(dat[i]>high)) cnt++;
    else if (dat[i]!=0) nullflag=0;
  if (cnt==0)
    if (nullflag)
      return -1;
  return cnt;
}



Long_t Det_LumiGEM::common_process()
{
  gemo->hits.clear();
  gemo->eval.clear();
  //  int eventid=eventinfo->eventNumber;
  //  int triggerpattern=eventinfo->trigFired;
   int triggerpattern=0xffff;

  // count the number of lumi triggers:
  //if (triggerpattern&0x02) {lumitriggercounter[0]++;}// cout<<"Lumi left\n\n";}
   // if (triggerpattern&0x04) {lumitriggercounter[1]++;}// cout<<"Lumi right\n\n";}

  if (viscotab)
    {
      LumiGUI->SetTriggerPatternOI();
      if (LumiGUI->CheckTriggerPattern()!=ok)
	{
	  debug(2, " LumiGEM::process(): skip!\n");
	  return maySkip;
	};
    };

  // Check trigger pattern:
  // if (triggerpatternOI<0xffff) // 0xffff is to override _everything_, even broken runs were trigFrired is always zero!
       //   if ((triggerpattern&triggerpatternOI)==0)
  //   return maySkip;

  // if (verbose)
  //  printf(" Event %6d has lumi trigger: trigFired = 0x%04x\n",  eventid, triggerpattern);

  // flags to remember data quality problems for this event:
  zeroFLAG=false;
  outofsyncFLAG=false;

  return ok;
}
  

bool Det_LumiGEM::common_process_inner(int t,int i)
{
  if (verbose>1)
    {
      printf("=======================================================\n");
      printf("===================== G E M  %d ========================\n", i);
      printf("=======================================================\n");
    };
   nx = GEM[t][i]->PushXdata();
   ny = GEM[t][i]->PushYdata();
  GEM[t][i]->GetXdata(xdat);
  GEM[t][i]->GetYdata(ydat);
    
  // printf(" nx and ny %d %d %d %d \n",t,i,nx,ny);

  // histogram mean rms's:
  double rmsxval=TMath::RMS(nx, xdat);
  double rmsyval=TMath::RMS(ny, ydat);
  if (rmshisto[t][i])
    {
      rmshisto[t][i]->Fill(rmsxval);
      rmshisto[t][i]->Fill(rmsyval);
    };
  LumiGEMeval eval;
  eval.GEMid = t*3+i;
  eval.rmsx = rmsxval;
  eval.rmsy = rmsyval;
  gemo->eval.push_back(eval);
    
  //
  // Check raw data for sync losses:
  //   Sync losses occur when an APV chip "forgets" its configuration
  //   and sends invalid data to the VME module or when the VME module
  //   ADC chip configuration breaks during a run (actually I don't know
  //   if the latter happens, but I'm pretty sure that the APV go crazy
  //   every once in a while.
  //   Such sync losses can be detected by checking the raw data for
  //   invalid values, i.e. beyond the range of the 12 bit ADCs like
  //   negative values or values >4095 counts.
  //   In order to be not too conservative and accept small hickups in
  //   the data stream we can specify a range inside the data is "valid"
  //   and a number of samples that need to be outside that range in
  //   order to raise the "bad_daqsync" flag.
  int outofsynccnt=0;
  int outofsynccntx = CheckRange(nx, xdat, valAPVsyncDataRangeLow, valAPVsyncDataRangeHigh);
  outofsynccnt += outofsynccntx;
  if (outofsynccnt==-1)
    {
      outofsynccnt = 0;
      // DetectorStatus |= LumiGEM::bad | LumiGEM::bad_zerodata;
      debug(0, " ----*****---- ZERO APV FRAME! t=%d GEM=%d X\n", t, i);
      zeroFLAG=true;
    };
  int outofsynccnty = CheckRange(ny, ydat, valAPVsyncDataRangeLow, valAPVsyncDataRangeHigh);
  //  if ( ((t==0)&&(i==1)) ) // left middle GEM has NO Y READOUT! Skip those channels here!
  //  outofsynccnty=0;
  outofsynccnt += outofsynccnty;
  H2((t*3+i)*2,   outofsynccntx, "APVsOutOfSync", "APVs out of sync", 12, -0.5, 11.5, 252, -1.5, 250.5);
  H2((t*3+i)*2+1, outofsynccnty, "APVsOutOfSync", "APVs out of sync", 12, -0.5, 11.5, 252, -1.5, 250.5);
  if (outofsynccnt==-1)
    {
      outofsynccnt = 0;
      // DetectorStatus |= LumiGEM::bad | LumiGEM::bad_zerodata;
      debug(0, " ----*****---- ZERO APV FRAME! t=%d GEM=%d Y\n", t, i);
      zeroFLAG=true;
    };
  if (outofsynccnt > valAPVoutOfSyncSampleThreshold)
    {
      //DetectorStatus |= LumiGEM::bad | LumiGEM::bad_daqsync;
      debug(0, " ----******---- OUT OF SYNC: %d samples in t=%d GEM=%d\n", outofsynccnt, t, i);
      outofsyncFLAG=true;
    };
   
 if ((i==0)||(i==1)) {
    apvx1=122;
    apvy1=122;
  };
  if (i==2) {
    apvx1=122;
    apvy1=128;
  };
  //  printf("check after %d %d %d  %d\n ",t,i,apvx1,apvy1);  

  //
  // If we should only do all the DetectorFlag stuff we can stop here:
  if (ProcessDetectorFlagOnly)
    return true;
  return false;
}
 

/////////////////////////////////////////////////////

void Det_LumiGEM::callib_apvchannels(int t,int i)
{
  int maxxadc,maxxch,maxyadc,maxych;  

  maxxadc = -10000;
  maxxch = 0;
  maxyadc = -10000;
  maxych = 0;
  for (int k=0; k<250; k++)		      
    {
      if(xdat[k]>maxxadc) //THis gets the maximum ADC value and it's strip # for xdat
	{
	  maxxadc=xdat[k];
	  maxxch =k;
	};
      if(ydat[k]>maxyadc) //THis gets the maximum ADC value and it's strip # for ydat
	{
	  maxyadc=ydat[k];
	  maxych =k;
	};
    };

  for (int k=0; k<250; k++)		      
    {
      //  if ((k==maxxch)&&(xdat[k]>500)&&(xdat[k]<1800)) //THis adds the maximum ADCs on each strip for # of "eve" events  
   if ((k==maxxch)) //THis adds the maximum ADCs on each strip for # of "eve" events 
	{
	  gettotx_adc[i][k] +=xdat[k];
	  gettotx_adc_e[i][k] = gettotx_adc_e[i][k]+1;
	   // printf("2 check after %d %d %d %d \n ",k,gettotx_adc[i][k],xdat[k],gettotx_adc_e[i][k]);
	};
  
      //  if ((k==maxych)&&(ydat[k]>500)&&(ydat[k]<1800)) //THis adds the maximum ADCs on each strip for # of "eve" events
     if ((k==maxych)) //THis adds the maximum ADCs on each strip for # of "eve" events
	{
	  gettoty_adc[i][k] +=ydat[k];
	  gettoty_adc_e[i][k] = gettoty_adc_e[i][k]+1;
	  //if (k==100)	  printf("check after %d %d %d %d\n ",i,k,gettoty_adc[i][k],gettoty_adc_e[i][k]);  
	};
    };
}

cmodeinfo_apv Det_LumiGEM::findCMode_apv(int t,int i)
{
  int maxxadc_apv1,maxxch_apv1,maxxadc_apv2,maxxch_apv2,maxyadc_apv1,maxych_apv1,maxyadc_apv2,maxych_apv2;  
  int gettoty_cmode_apv1,gettoty_cmode_e_apv1,gettoty_cmode_apv2,gettoty_cmode_e_apv2,gettotx_cmode_apv1,gettotx_cmode_e_apv1,gettotx_cmode_apv2,gettotx_cmode_e_apv2;

  maxxadc_apv1 = 0;
  maxxch_apv1 = 1000;
  maxyadc_apv1 = 0;
  maxych_apv1 = 1000;
  maxxadc_apv2 = 0;
  maxxch_apv2 = 1000;
  maxyadc_apv2 = 0;
  maxych_apv2 = 1000;

 for (int k=0; k<apvx1; k++)		      
    {
      if(xdat[k]>maxxadc_apv1) //THis gets the maximum ADC value and it's strip # for xdat
	{
	  maxxadc_apv1 =xdat[k];
	  maxxch_apv1 =k;
	};
    };
 for (int k=apvx1; k<250; k++)		      
   {
     if(xdat[k]>maxxadc_apv2) //THis gets the maximum ADC value and it's strip # for xdat
       {
	 maxxadc_apv2 =xdat[k];
	 maxxch_apv2 =k;
       };
   };

 for (int k=0; k<apvy1; k++)		      
   {
     if(ydat[k]>maxyadc_apv1) //THis gets the maximum ADC value and it's strip # for xdat
       {
	 maxyadc_apv1 =ydat[k];
	 maxych_apv1 =k;
       };
   };
for (int k=apvy1; k<250; k++)		      
   {
     if(ydat[k]>maxyadc_apv2) //THis gets the maximum ADC value and it's strip # for xdat
       {
	 maxyadc_apv2 =ydat[k];
	 maxych_apv2 =k;
       };
   };

  gettotx_cmode_e_apv1=0;
  gettoty_cmode_e_apv1=0;
  gettotx_cmode_apv1=0;
  gettoty_cmode_apv1=0;

  gettotx_cmode_e_apv2=0;
  gettoty_cmode_e_apv2=0;
  gettotx_cmode_apv2=0;
  gettoty_cmode_apv2=0;

/// for the first APV on both X and Y ////////////////////

  for (int k=0; k<apvx1; k++)		      
    {
      if ((k<=maxxch_apv1-2)||(k>=maxxch_apv1+2)) //THis adds ADCs for each strip without the maximum ADC strip # +/- 2 on each event
	{
	  gettotx_cmode_apv1 +=xdat[k];
	  gettotx_cmode_e_apv1 = gettotx_cmode_e_apv1+1;
	};
    };
 for (int k=apvx1; k<250; k++)		      
    {
      if ((k<=maxxch_apv2-2)||(k>=maxxch_apv2+2)) //THis adds ADCs for each strip without the maximum ADC strip # +/- 2 on each event
	{
	  gettotx_cmode_apv2 +=xdat[k];
	  gettotx_cmode_e_apv2 = gettotx_cmode_e_apv2+1;
	};
    };

 for (int k=0; k<apvy1; k++)		      
   {
      if ((k<=maxych_apv1-2)||(k>=maxych_apv1+2)) //THis adds ADCs for each strip without the maximum ADC strip # +/- 2 on each event
	{
	  gettoty_cmode_apv1 +=ydat[k];
	  gettoty_cmode_e_apv1 = gettoty_cmode_e_apv1+1;
	};
    };

 for (int k=apvy1; k<250; k++)		      
   {
     if ((k<=maxych_apv2-2)||(k>=maxych_apv2+2)) //THis adds ADCs for each strip without the maximum ADC strip # +/- 2 on each event
       {
	 gettoty_cmode_apv2 +=ydat[k];
	 gettoty_cmode_e_apv2 = gettoty_cmode_e_apv2+1;
       };
   };
 
  cmodeinfo_apv cm_apv;
  cm_apv.x_event_apv1=gettotx_cmode_apv1/gettotx_cmode_e_apv1; // gives the average non-cluster ADC on each event on first X apv
  cm_apv.y_event_apv1=gettoty_cmode_apv1/gettoty_cmode_e_apv1; // gives the average non-cluster ADC on each event on first Y apv
  cm_apv.x_event_apv2=gettotx_cmode_apv2/gettotx_cmode_e_apv2; // gives the average non-cluster ADC on each event on second X apv
  cm_apv.y_event_apv2=gettoty_cmode_apv2/gettoty_cmode_e_apv2; // gives the average non-cluster ADC on each event on second Y apv
  
  cm_apv.x_apv1=(gettotx_cmode_apv1/gettotx_cmode_e_apv1)-cmode_mean_x_apv1[t][i]; //cm for first X apv
  cm_apv.y_apv1=(gettoty_cmode_apv1/gettoty_cmode_e_apv1)-cmode_mean_y_apv1[t][i]; //cm for first Y apv
  cm_apv.x_apv2=(gettotx_cmode_apv2/gettotx_cmode_e_apv2)-cmode_mean_x_apv2[t][i]; //cm for second X apv
  cm_apv.y_apv2=(gettoty_cmode_apv2/gettoty_cmode_e_apv2)-cmode_mean_y_apv2[t][i]; //cm for second Y apv

  cm_apv.maxx_apv1=maxxadc_apv1; //maximum X ADC on first APV
  cm_apv.maxy_apv1=maxyadc_apv1; //maximum Y ADC on first APV
  cm_apv.maxchx_apv1=maxxch_apv1; //THe channel which gives maximum X ADC on first APV
  cm_apv.maxchy_apv1=maxych_apv1;//THe channel which gives maximum X ADC on first APV

  cm_apv.maxx_apv2=maxxadc_apv2;
  cm_apv.maxy_apv2=maxyadc_apv2;
  cm_apv.maxchx_apv2=maxxch_apv2;
  cm_apv.maxchy_apv2=maxych_apv2;
 
  //  printf("check befre %d %d %5.2lf %5.2lf\n ",t,i,cmode_mean_x[t][i],cmode_mean_y[t][i]);
  //  printf("check after %d %d  %d %d\n ",cm.x_event,cm.y_event,cm.x,cm.y);  

  return cm_apv;
}


//////////////////////////////////////////////////////////

void Det_LumiGEM::subtractCMode(int t,int i,cmodeinfo_apv &info)
{
  for (int k=0; k<250; k++)		      
    {
      if ((i==0)||(i==1)) {
	if (k<122) {
	  xdat[k]-=info.x_apv1;
	  ydat[k]-=info.y_apv1;
	};
	if (k>121) {
	  xdat[k]-=info.x_apv2;
	  ydat[k]-=info.y_apv2;
	};
      };
      if (i==2) {
	if (k<122) xdat[k]-=info.x_apv1;
	if (k>121) xdat[k]-=info.x_apv2;
	if (k<128) ydat[k]-=info.y_apv1;
	if (k>127) ydat[k]-=info.y_apv2;
      };
    };
}
 

void Det_LumiGEM::subtractBin2Bin(int t,int i)
{
  for (int k=0;k<250;k++)
    {

      xdat[k]-=avg_ped_x[i][k];
      ydat[k]-=avg_ped_y[i][k];
      //  xdat[k]-=perchannelped[k*2+2*250*i+2*250*3*t];
      //  ydat[k]-=perchannelped[1+k*2+2*250*i+2*250*3*t];
      //      debug(0,"%i %i %i %i %i\n",k,i,t,1+k*2+2*250*i+2*250*3*t,perchannelped[1+k*2+2*250*i+2*250*3*t]);
      // printf ("channels per ped %i %i %i %i %i\n",t,i,k,k*2+2*250*i+2*250*3*t,perchannelped[k*2+2*250*i+2*250*3*t]);
    }
}
void Det_LumiGEM::dobaselinesub(int t, int i)
{
  if (verbose>1)
	    printf(" %d x samples, %d y samples\n", nx, ny);
	  
	    hitfinder->SetPreProcessMethod(cHitFinder::ppRemoveLinearBaseline);
	   // //hitfinder->SetPreProcessMethod(cHitFinder::ppDoNothing);	    
	   hitfinder->RemoveLinearBaseline(GEM[t][i]->GetNXsamplesList(), xdat);
	   hitfinder->RemoveLinearBaseline(GEM[t][i]->GetNYsamplesList(), ydat);
}

Long_t Det_LumiGEM::Channel_2_channel_gain_calib(int id, int tele, int gem, int strip, int dir, double calibc)
{
  CalibConsts[1500*tele+500*gem+2*strip+dir]=calibc;
  //printf(" Calibration Constants %d %d %d %d %8.5lf\n",tele,gem,strip,dir,CalibConsts[1500*tele+500*gem+2*strip+dir]);
  return ok;
}

void Det_LumiGEM::findClusters(int t, int i)
{
	     
  // find clusters:
  if (verbose>1)
    printf(" %d x samples, %d y samples\n", nx, ny);
	  
  // copy data to use  later:
  memcpy(xdatraw, xdat, nx*sizeof(xdat[0]));
  memcpy(ydatraw, ydat, ny*sizeof(ydat[0]));

  hitfinder->GaussFilter(nx, xdat, valLMGaussFilterSigma, tmpdat);
  hitfinder->GaussFilter(ny, ydat, valLMGaussFilterSigma, tmpdat);

  int xlist[16], ylist[16];
  //printf("x local maxima \n");
  int nlmx = hitfinder->FindLocalMaxima(nx, xdat, xlist, valLMMaximumNLM, valLMMinimumDistance, valLMMinimumAmplitude);
  //printf("y local maxima \n");
  int nlmy = hitfinder->FindLocalMaxima(ny, ydat, ylist, valLMMaximumNLM, valLMMinimumDistance, valLMMinimumAmplitude);

  if (verbose>1)
        printf(" %d LM in x and %d LM in y\n", nlmx, nlmy);

  if (valrepairbrokenstrips)
    {
      /*int brokenstripsx =*/ hitfinder->RepairBrokenStrips(nx, xdatraw);
      /*int brokenstripsy =*/ hitfinder->RepairBrokenStrips(ny, ydatraw);
    };

  // go through the list of local maxima and check if they belong to clusters:
  LumiGEMhit  hit;
  hitlist.clear();
  xclustercnt[i]=0;
  for (int j=0; xlist[j]>=0; j++)
    {
      if (hitfinder->CheckClusterCandidate(xlist[j], valCFMinimumAmplitude, xdat, xdatraw, nx, &hit)>0)
	{	 
	  if (verbose>1)
	    printf(" ====> X CLUSTER: @%d <====\n", xlist[j]);
	  // push hit into vector:
	  hit.GEMid = i+t*3;
	  if (valmake1dhits) 
	    gemo->hits.push_back(hit);
	  else
	    hitlist.push_back(hit);
	  H1(hit.ampl, Form("%sGEM%dAmplX", leftright[t], i), Form("%sGEM%dAmplX", leftright[t], i),
	     250, 0., 2500.);
	  H1(hit.sigma, Form("%sGEM%dSigmaX", leftright[t], i), Form("%sGEM%dSigmaX", leftright[t], i),
	     250, 0., 3.);
	  H2(hit.ampl, hit.sigma, Form("%sGEM%dSigmaVsAmplX", leftright[t], i),
	     Form("%sGEM%dSigmaVsAmplX", leftright[t], i),
	     250, 0., 2500., 250, 0., 3.);
	  xclustercnt[i]++;
	};
    };
 
  estlumicounter += xclustercnt[i];
  //  hitlist.clear();
  yclustercnt[i]=0;
  for (int j=0; ylist[j]>=0; j++)
    {
      if (hitfinder->CheckClusterCandidate(ylist[j], valCFMinimumAmplitude, ydat, ydatraw, ny, &hit)>0)
	{
	  if (verbose>1)
	    printf(" ====> Y CLUSTER: @%d <====\n", ylist[j]);
	  // push hit into vector:
	  hit.GEMid = i+t*3;
	  hit.yl = hit.xl; hit.ylerr = hit.xlerr;
	  hit.xl = -1;     hit.xlerr = 0.;
	  if (valmake1dhits) {
	    gemo->hits.push_back(hit); }
	  else {
	    hitlist.push_back(hit);
	    H1(hit.ampl, Form("%sGEM%dAmplY", leftright[t], i), Form("%sGEM%dAmplY", leftright[t], i),
	       250, 0., 2500.);
	    H1(hit.sigma, Form("%sGEM%dSigmaY", leftright[t], i), Form("%sGEM%dSigmaY", leftright[t], i),
	       250, 0., 3.);
	    H2(hit.ampl, hit.sigma, Form("%sGEM%dSigmaVsAmplY", leftright[t], i),
	       Form("%sGEM%dSigmaVsAmplY", leftright[t], i),
	       250, 0., 2500., 250, 0., 3.);
	    yclustercnt[i]++; }
	};
    };
  estlumicounter += yclustercnt[i];

  // Charge sharing (if wanted by user):
  if (valmake1dhits==0)
    {
      // we need to treat the left sector middle GEM separately:
      if ( (t==0)&&(i==1) && false) //this is disabled because they seem to work!
	// 'ChargeFaking' will produce a "fake" cluster in y with sigma=99.9 
	//  in the center of the detector. In track fitting the yerr of this GEM
	//  should be set to something like Â±100mm or so to make sure it doesn't
	//  affect tracking at all.
	hitfinder->ChargeFaking(hitlist, &(gemo->hits));
      else
	//printf("go through charge sharing\n");
	hitfinder->ChargeSharing(hitlist, &(gemo->hits));
    };

}

////////////////////////////////////////////////////////////////////
 
Long_t Det_LumiGEM::process()
{
  if (Long_t r=common_process()!=ok) return r;
  
  int gettoty_onlycmode,gettotx_onlycmode,gettoty_onlycmode_e,gettotx_onlycmode_e;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  for (int t=1; t<2; t++)  // two telescopes
    {
      
      if (LUMI[t]==NULL){continue;}
      lumibankcounter[t]++;
      if (verbose>1) printf(" processing LUMI[%d]:\n", t);
      for (int i=0; i<3; i++)
	GEM[t][i]->ClearAPVs();
      if (ReadTelescopeData(t)==0) { // is there any lumi data for this event?
	continue;}
      for (int i=0; i<3; i++)// three GEMs per telescope
	{
	 
	  if (common_process_inner(t,i)) continue;

	  int xraw[250],yraw[250];	 
	  for (int k=0; k<250; k++) 		      
	    {
	      xraw[k]=xdat[k];
	      yraw[k]=ydat[k];	   
	    };       
	  
	  cmodeinfo_apv cminfo_apv=findCMode_apv(t,i);
	  if (someSpecHist)
	  {
	    h1adcspec_cmode_x_apv1[t][i]->Fill(cminfo_apv.x_event_apv1);
	    h1adcspec_cmode_y_apv1[t][i]->Fill(cminfo_apv.y_event_apv1);	  
	    h1adcspec_cmode_x_apv2[t][i]->Fill(cminfo_apv.x_event_apv2);
	    h1adcspec_cmode_y_apv2[t][i]->Fill(cminfo_apv.y_event_apv2);	  
	  };

	  //	  if (allSpecHist)
	  //    {
	  //      h2maxxADCb4cm[t][i]->Fill(cminfo.maxchx,cminfo.maxx);
	  //      h2maxyADCb4cm[t][i]->Fill(cminfo.maxchy,cminfo.maxy);
	  //    };

	 
	  /////////////////// Total "raw" ADC vs strip #.  (before applying common-mode noise, bin-2-bin pedestals or polynomial fit baseline subtractions.////////////////////////////

	  if (allSpecHist)
	    for (int k=0; k<250; k++)		      
	      {
		h2adcspec_x[t][i]->Fill(k,xdat[k]);
		h2adcspec_y[t][i]->Fill(k,ydat[k]);
		//Get the total X/Y ADCs and # of events on each strip excluding the maximum ADC strip # +/- 2 for each event
		if (((k<apvx1)&&((k<=cminfo_apv.maxchx_apv1-2)||(k>=cminfo_apv.maxchx_apv1+2)))||((k>apvx1-1)&&((k<=cminfo_apv.maxchx_apv2-2)||(k>=cminfo_apv.maxchx_apv2+2)))) {		       
		  h2adcspec_nopk_x[t][i]->Fill(k,xdat[k]);
		  dattotx_nopk_ent[i][k]=dattotx_nopk_ent[i][k]+1;
		};
		if (((k<apvy1)&&((k<=cminfo_apv.maxchy_apv1-2)||(k>=cminfo_apv.maxchy_apv1+2)))||((k>apvy1-1)&&((k<=cminfo_apv.maxchy_apv2-2)||(k>=cminfo_apv.maxchy_apv2+2)))) {
		  h2adcspec_nopk_y[t][i]->Fill(k,ydat[k]);
		  dattoty_nopk_ent[i][k]=dattoty_nopk_ent[i][k]+1;
		};

		h2evespec_nopk_x[t][i]->Fill(k,dattotx_nopk_ent[i][k]);
		h2evespec_nopk_y[t][i]->Fill(k,dattoty_nopk_ent[i][k]);
	      };

	  ////////////////////////// Only bin-2-bin subtraction//////////////////////////////////////
	  ////If you need to check the effects only when the bin to bin subtractions, you should turn ON the flag "onlybin2binsub". 
	  ////However, because all these bin-2-bin pedestals are determined only after common mode subtraction, then you have to 
	  ////turn OFF the "doSubtractcmode" flag on Long_t Det_LumiGEM::startup_findPedestal() doSubtractcmode=false; or just commented out the flag.
	 cmodeinfo_apv cminfo_apv_onlyb2b=findCMode_apv(t,i);
	  if (onlybin2binsub){
	    if (doSubtractped) subtractBin2Bin(t,i);
	    if (allSpecHist) {
	      for (int k=0; k<250; k++)		      
	  	{
		  if (((k<apvx1)&&((k<=cminfo_apv_onlyb2b.maxchx_apv1-2)||(k>=cminfo_apv_onlyb2b.maxchx_apv1+2)))||((k>apvx1-1)&&((k<=cminfo_apv_onlyb2b.maxchx_apv2-2)||(k>=cminfo_apv_onlyb2b.maxchx_apv2+2)))) 
	  	    h2adcspec_pedsub_nopk_x[t][i]->Fill(k,xdat[k]);
		  if (((k<apvy1)&&((k<=cminfo_apv_onlyb2b.maxchy_apv1-2)||(k>=cminfo_apv_onlyb2b.maxchy_apv1+2)))||((k>apvy1-1)&&((k<=cminfo_apv_onlyb2b.maxchy_apv2-2)||(k>=cminfo_apv_onlyb2b.maxchy_apv2+2)))) 
		    h2adcspec_pedsub_nopk_y[t][i]->Fill(k,ydat[k]);
	  	};
	    };
	  };

	  //////////////////////////////////////////////////////////////////////////////////////////
	
	  if (doSubtractcmode) subtractCMode(t,i,cminfo_apv); //////Subtract common mode
	  cmodeinfo_apv cminfo_apv_cm=findCMode_apv(t,i);
	  if (allSpecHist)
	    {
	      //   h2maxxADCcm[t][i]->Fill(cminfo.maxchx,cminfo.maxx);
	      //   h2maxyADCcm[t][i]->Fill(cminfo.maxchy,cminfo.maxy);
	    }
	  if (someSpecHist)
	    for (int k=0; k<250; k++)		      
	      {
		if (allSpecHist)
		  {
		    h2adcspec_cmode_x[t][i]->Fill(k,xdat[k]);
		    h2adcspec_cmode_y[t][i]->Fill(k,ydat[k]);
		  }
		if (((k<apvx1)&&((k<=cminfo_apv_cm.maxchx_apv1-2)||(k>=cminfo_apv_cm.maxchx_apv1+2)))||((k>apvx1-1)&&((k<=cminfo_apv_cm.maxchx_apv2-2)||(k>=cminfo_apv_cm.maxchx_apv2+2)))) {
		  h2adcspec_cmode_nopk_x[t][i]->Fill(k,xdat[k]);
		  gettotpedx[i][k] +=xdat[k];
		  gettotpedxentries[i][k]=gettotpedxentries[i][k]+1;
		};
		if (((k<apvy1)&&((k<=cminfo_apv_cm.maxchy_apv1-2)||(k>=cminfo_apv_cm.maxchy_apv1+2)))||((k>apvy1-1)&&((k<=cminfo_apv_cm.maxchy_apv2-2)||(k>=cminfo_apv_cm.maxchy_apv2+2)))) {
		  h2adcspec_cmode_nopk_y[t][i]->Fill(k,ydat[k]);
		  gettotpedy[i][k] +=ydat[k];
		  gettotpedyentries[i][k]=gettotpedyentries[i][k]+1;
		};
		//	printf("get ped %d %d %d %d %d \n",k,gettotpedx[i][k],gettotpedxentries[i][k],gettotpedy[i][k],gettotpedyentries[i][k]);
	      };	    
	 
	  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	  if (doSubtractped) subtractBin2Bin(t,i);  //////Subtract bin-to-bin pedestals (after common mode)
	  // if (doSubtractped) printf("get ped \n");
	  cmodeinfo_apv cminfo_apv_b2b=findCMode_apv(t,i);
	  if (someSpecHist) {
	    for (int k=0; k<250; k++)		      
	      {
		if (allSpecHist)
		  {		  
		    h2adcspec_cm_pedsub_x[t][i]->Fill(k,xdat[k]);
		    h2adcspec_cm_pedsub_y[t][i]->Fill(k,ydat[k]);
		  }
		//	if (someSpecHist) {
		if (((k<apvx1)&&((k<=cminfo_apv_b2b.maxchx_apv1-2)||(k>=cminfo_apv_b2b.maxchx_apv1+2)))||((k>apvx1-1)&&((k<=cminfo_apv_b2b.maxchx_apv2-2)||(k>=cminfo_apv_b2b.maxchx_apv2+2))))
		  h2adcspec_cm_pedsub_nopk_x[t][i]->Fill(k,xdat[k]);
	
		if (((k<apvx1)&&((k>cminfo_apv_b2b.maxchx_apv1-2)&&(k<cminfo_apv_b2b.maxchx_apv1+2)))||((k>apvx1-1)&&((k>cminfo_apv_b2b.maxchx_apv2-2)&&(k<cminfo_apv_b2b.maxchx_apv2+2)))&&(xdat[k]>0)) 
		  h2adcspec_cm_pedsub_peak_x[t][i]->Fill(k,xdat[k]);

		if (((k<apvy1)&&((k<=cminfo_apv_b2b.maxchy_apv1-2)||(k>=cminfo_apv_b2b.maxchy_apv1+2)))||((k>apvy1-1)&&((k<=cminfo_apv_b2b.maxchy_apv2-2)||(k>=cminfo_apv_b2b.maxchy_apv2+2))))
		  h2adcspec_cm_pedsub_nopk_y[t][i]->Fill(k,ydat[k]);

		if (((k<apvy1)&&((k>cminfo_apv_b2b.maxchy_apv1-2)&&(k<cminfo_apv_b2b.maxchy_apv1+2)))||((k>apvy1-1)&&((k>cminfo_apv_b2b.maxchy_apv2-2)&&(k<cminfo_apv_b2b.maxchy_apv2+2)))&&(ydat[k]>0)) 
		  h2adcspec_cm_pedsub_peak_y[t][i]->Fill(k,ydat[k]);
	      };
	  };
	   
	  //////////////////// check common-mode noise after both cmode and bin-2-bin pedestal subtraction ////////////
	  cmodeinfo_apv cminfo_after=findCMode_apv(t,i);
	  if (allSpecHist)
	    {
	      //  h2maxxADCcmped[t][i]->Fill(cminfo_after.maxchx,cminfo_after.maxx);
	      // h2maxyADCcmped[t][i]->Fill(cminfo_after.maxchy,cminfo_after.maxy);
	    };
	    
	  //////////////////////////////////////////////////////////////////////////////////////////////////////////
	  if (doSubtractbaseline) {	 
	    /// This is only to check the baseline subtraction effets without common-mode or bin-2-bin pedestal subtractions. So, the raw data is using.//////
	    for (int k=0; k<250; k++)		      
	      {
		xdat[k]=xraw[k];
		ydat[k]=yraw[k];
	      };
	    
	    dobaselinesub(t,i);
	    cmodeinfo cminfo_base=findCMode(t,i);
	    if (allSpecHist)
	      for (int k=0; k<250; k++)		      
		{
		  h2adcspec_base_x[t][i]->Fill(k,xdat[k]);
		  h2adcspec_base_y[t][i]->Fill(k,ydat[k]);
		  
		  if ((k<=cminfo_base.maxchx-2)||(k>=cminfo_base.maxchx+2)) 
		    h2adcspec_base_nopk_x[t][i]->Fill(k,xdat[k]);
		  if ((k<=cminfo_base.maxchy-2)||(k>=cminfo_base.maxchy+2)) 
		    h2adcspec_base_nopk_y[t][i]->Fill(k,ydat[k]);
		};
	  }
	  /////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	  totent[t][i]=totent[t][i]+1;
	  if (allSpecHist) totentries[t][i]->Fill(totent[t][i]);
	  for (int ky=0; ky<250; ky++)		      
	    {
	      int amply  = ydat[ky];
	      if (amply>300) {
		//	totampy[t][i][ky]=totampy[t][i][ky]+amply;
		//	totampenty[t][i][ky]=totampenty[t][i][ky]+1;
		for (int kx=0; kx<250; kx++)		      
		  {
		    int amplx  = xdat[kx];	   
		    if (amplx>300){
		      totampy[t][i][ky]=totampy[t][i][ky]+amply;
		      totampenty[t][i][ky]=totampenty[t][i][ky]+1;

		      totampx[t][i][kx]=totampx[t][i][kx]+amplx;
		      totampentx[t][i][kx]=totampentx[t][i][kx]+1;
	     
		      if (allSpecHist) {
			h2amplmapsx[t][i]->Fill(kx,ky,amplx);
			h2amplmapsy[t][i]->Fill(kx,ky,amply);   		
			h2hitmaps[t][i]->Fill(kx,ky);
			H_hitampx[t][i]->Fill(amplx);
			H_hitampy[t][i]->Fill(amply);
		      };
		      //printf("process  xdat ydat %d %d %d %d %d %d \n",kx,ky,totampx[kx][ky],amplx,totampy[kx][ky],amply);
		    }; 
		  };
	      };
	    };
	  
 /////////////////////////////////////////Dead Channels Masking /////////////////////////////////////////
	  if (dead_ch_masking) {   
	    for (int k=0; k<250; k++)
	      {
		if (deadchannels[k*2+2*250*i+2*250*3*t]>0) {
		  //	printf ("X channels per ped %i %i %i %i %i %i\n",t,i,k,k*2+2*250*i+2*250*3*t,deadchannels[k*2+2*250*i+2*250*3*t],xdat[deadchannels[k*2+2*250*i+2*250*3*t]]);   
		  xdat[deadchannels[k*2+2*250*i+2*250*3*t]]=-100000;
		};
		if (deadchannels[k*2+2*250*i+2*250*3*t+1]>0) {
		  //	printf ("Y channels per ped %i %i %i %i %i %i\n",t,i,k,k*2+2*250*i+2*250*3*t,deadchannels[k*2+2*250*i+2*250*3*t],xdat[deadchannels[k*2+2*250*i+2*250*3*t]]);   
		  ydat[deadchannels[k*2+2*250*i+2*250*3*t+1]]=-100000;	
		};

		for (int ky=0; ky<250; ky++)
		  {
		    if ((deadchannels[k*2+2*250*i+2*250*3*t]>0)||(deadchannels[ky*2+2*250*i+2*250*3*t+1]>0)) {
		      if (someSpecHist) {
			deadchmap[t][i]->Fill(k,ky);
		      };
		    };
		  };
	      };
	  };
    
 ///////////////////////Do APV Channel-2-channel gain calibration//////////////////////////////////////
	 
	  if (use_gainmatch) { /// Use APV channel-to-channel gain match//////
	    for (int k=0; k<250; k++)
	      {    
		//	if ((k==34)||(k==42)||(k==66)) printf ("Calibration Constants before %i %i %i %i %i \n",t,i,k,xdat[k],ydat[k]);

		if (deadchannels[k*2+2*250*i+2*250*3*t]>0) xdat[deadchannels[k*2+2*250*i+2*250*3*t]]=-100000;
		else {
		  if (xdat[k]>0) xdat[k]=xdat[k]*CalibConsts[1500*t+500*i+2*k];
		  else  xdat[k]=xdat[k]-xdat[k]*CalibConsts[1500*t+500*i+2*k];
		};

		if (deadchannels[k*2+2*250*i+2*250*3*t+1]>0) ydat[deadchannels[k*2+2*250*i+2*250*3*t+1]]=-100000; 
		else {
		  if (ydat[k]>0) ydat[k]=ydat[k]*CalibConsts[1500*t+500*i+2*k+1];
		  else ydat[k]=ydat[k]-ydat[k]*CalibConsts[1500*t+500*i+2*k+1];
		};
		//  printf ("Calibration Constants after %i %i %i %i %i \n",t,i,k,xdat[k],ydat[k]); 

		//	if ((k==34)||(k==42)||(k==66)) printf ("Calibration Constants after %i %i %i %i %i \n",t,i,k,xdat[k],ydat[k]); 
	      };
	  };
       
/////////////////////////////////// APV channel-to-channel gain calibration ////////////////////////
	   if (doAPVcalib) callib_apvchannels(t,i); /// Determine the  APV channel-to-channel gain calibration constants//////
//////////////////////////////////////////////////////////////////////////////////////////////////////

	  if (doFindClusters)
	    findClusters(t,i);


	  //delete[] xraw;
	  //delete[] yraw;
	
	}; // for i (GEMs)
    }; // for t (telescopes)

  // check if any GEM had bad raw data:
  if (zeroFLAG)
    APVzeroSamplesCNT++; // count this as a zerosamples event
  if (outofsyncFLAG)
    APVoutOfSyncCNT++; // count this as an outofsync event



  // loop over all hits found in all GEMs to make
  // correlation plots like x vs x and y vs y:
  std::vector <LumiGEMhit> xyhits[2][3]; // need xy cluster list for each GEM element!
  for (unsigned int j=0; j<gemo->hits.size(); j++)
    {
      int GEMid = gemo->hits[j].GEMid;
      int t = GEMid/3; // which telescope
      int g = GEMid%3;
      // create temporary GEMhit to push it to vector of hits:
      LumiGEMhit ahit;
      ahit.xl = gemo->hits[j].xl;
      ahit.yl = gemo->hits[j].yl;
      xyhits[t][g].push_back(ahit);
      // fill 2d hitmaps:
     
      H_hitmap2d[t][g]->Fill(gemo->hits[j].xl, gemo->hits[j].yl);

      if (allSpecHist) H_amplmap2d[t][g]->Fill(gemo->hits[j].xl, gemo->hits[j].yl, gemo->hits[j].ampl);
    };

  /*
  // cut on MI GEM:
  bool good=true;
  for (unsigned int i=0; i<xyhits[0][0].size(); i++)
  {
  // double yl=xyhits[0][1][i].yl;
  // if ( (yl<120.)||(yl>130.) )
  // 	{
  // 	  good=false;
  // 	  break;
  // 	};
  double yl=xyhits[0][0][i].yl;
  if ( (yl<125.)||(yl>135.) )
  {
  good=false;
  break;
  };
  };
  */
  // now we have all clusters in xyhits:
  // nested loop over all GEMs to fill correlation plots:
  //    if (good)
  for (int  t=0; t<2; t++)
    for (int i=0; i<3; i++)
      for (int j=0; j<3; j++)
	{
	  if (i==j) continue;
	  for (unsigned int ihit=0; ihit<xyhits[t][i].size(); ihit++)
	    for (unsigned int jhit=0; jhit<xyhits[t][j].size(); jhit++)
	      {
		H_XvsX[t][i][j]->Fill(xyhits[t][i][ihit].xl,
				      xyhits[t][j][jhit].xl);
		H_YvsY[t][i][j]->Fill(xyhits[t][i][ihit].yl,
				      xyhits[t][j][jhit].yl);
	      };
	};

 

  if (viscotab)
    {
      //printf(" %8d: triggerpattern = 0x%x\n", eventid, triggerpattern);
      //      LumiGUI->FillHitMaps();
      LumiGUI->DrawRawData();
      LumiGUI->SimpleTracking();
    };
  //   };// we need the SiPM TDC

  return ok;
}


////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////



Long_t Det_LumiGEM::showTraces()
{
  if (viscotab==NULL)
    return ok;
  return LumiGUI->showTraces();
}

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

Long_t Det_LumiGEM::done()
{
  /*  if (SCManager)
      {
      beamcharge   += (SC_BeamCurrent->value)*1e-3*(runstoptime-lasteventtime);
      printf("total integrated beam charge = %eC in %.3lfs\n", beamcharge, runstoptime-runstarttime);
      };
  */
  // show info about trigger counts:
  printf("\n LumiGEM: trigger summary follows...\n ===== TRIGGER COUNTS =====\n");
  if (lumitriggercounter[0])
    printf(" lumi left:  %7d banks in %7d triggers (%3.2lf%%)\n",
	   lumibankcounter[0], lumitriggercounter[0], (double)lumibankcounter[0]/(double)lumitriggercounter[0]*100.);
  else
    printf(" lumi left: no triggers!!\n");
  if (lumitriggercounter[1])
    printf(" lumi right: %7d banks in %7d triggers (%3.2lf%%)\n",
	   lumibankcounter[1], lumitriggercounter[1], (double)lumibankcounter[1]/(double)lumitriggercounter[1]*100.);
  else
    printf(" lumi right: no triggers!!\n");

  // check monitored slow control channels:
  printf("\nMonitored Slow Control Channels:\n");
  int anythingbad=0;
  /*
    for (int t=0; t<2; t++)
    for (unsigned int i=0; i<SCMonitor[t].size(); i++)
    {
    printf(" %s\t%s\n", SCMonitor[t][i].name, goodbad[SCMonitor[t][i].wasbad]);
    anythingbad += SCMonitor[t][i].wasbad;
    };
  */
  int oldstatus=DetectorStatus;
  // Check for HV problems:
  if (anythingbad) // some HV problem?
    DetectorStatus |= LumiGEM::bad | LumiGEM::bad_hv;
  // Check for raw data quality problems:
  if (APVzeroSamplesCNT > valAPVzeroSamplesEventThreshold) // too many bad events?
    DetectorStatus |= LumiGEM::bad | LumiGEM::bad_zerodata;
  if (APVoutOfSyncCNT > valAPVoutOfSyncEventThreshold) // too many bad events?
    DetectorStatus |= LumiGEM::bad | LumiGEM::bad_daqsync;
  // if something was bad mask out "good" (should not be on anyway, but who knows?)
  if (DetectorStatus & LumiGEM::bad)
    DetectorStatus &= (~LumiGEM::good);
  else // otherwise the status is "good"
    DetectorStatus |= LumiGEM::good;
  // write detector status to database:
  setDetectorFlag("LumiGEM", DetectorStatus);
  printf(" DetectorStatus = %d\n", DetectorStatus);
  if (strlen(WriteDetectorFlagFilename)!=0)
    {
      FILE *file=NULL;
      int fopencnt=0;
      while (file==NULL)
	{
	  file = fopen(WriteDetectorFlagFilename, "a");
	  fopencnt++;
	  usleep(10000);
	  if (fopencnt>25) break;
	};
      if (file)
	{
	  fprintf(file, "%d\t%d APVzeroCNT:\t%d APVoutofsyncCNT:\t%d\n",
		  runinfo->runNumber, DetectorStatus, APVzeroSamplesCNT, APVoutOfSyncCNT);
	  fclose(file);
	}
      else
	printf(" ***** CANNOT OPEN TEXT FILE FOR DETECTOR FLAG OUTPUT *****\n");
    };

  out->Draw("LumiGEMhits.hits.sigma>>hCFsigma(300,0.0,3.0)");


  for (int t=1;t<2;t++){
    for (int i=0;i<3;i++)
      {
	//	int tot_ent = totentries[t][i]->GetEntries();
	for (int x=0;x<250;x++){
	  double avgampx=(double)totampx[t][i][x]/totampentx[t][i][x];
	  double avgampy=(double)totampy[t][i][x]/totampenty[t][i][x];
		   
	  //  if (totampx[t][i][x]>0)  printf("process  xdat ydat %d %d %d %d %d %g\n",t,i,x,totampx[t][i][x],totampentx[t][i][x],avgampx);
	  //	  if (allSpecHist) normamplmapsx[t][i]->Fill(x,avgampx);
	  //	  if (allSpecHist) normamplmapsy[t][i]->Fill(x,avgampy);
	};
      };
  };
  ////////////////////////////////////////////////////////////////////////////
  cleanup();
  return 0;
}

Long_t Det_LumiGEM::getmean_cmode()
{
  if (doSubtractcmode)
    debug(0,"***************\nWarning: common mode has been subtracted! Please deactivate the 'doSubtractcmode' \n**************\n");

   ofstream outf("event_avg_cmode.dat");
  //  int id=0;
  for (int t=0;t<2;t++)
    for (int i=0;i<3;i++)
      {
	//Get the mean of common mode spectra histogram:

	double meancm_x_apv1=h1adcspec_cmode_x_apv1[t][i]->GetMean();
	double meancm_y_apv1=h1adcspec_cmode_y_apv1[t][i]->GetMean();

	double meancm_x_apv2=h1adcspec_cmode_x_apv2[t][i]->GetMean();
	double meancm_y_apv2=h1adcspec_cmode_y_apv2[t][i]->GetMean();

		printf(" get cmode mean %d %d %5.2lf %5.2lf %5.2lf %5.2lf\n", t,i, meancm_x_apv1, meancm_x_apv2, meancm_y_apv1, meancm_y_apv2);
	
		outf<< t<<"\t"<<i<<"\t"<<meancm_x_apv1<<"\t"<<meancm_x_apv2<<"\t"<<meancm_y_apv1<<"\t"<<meancm_y_apv2<<std::endl;    
      }    
   outf.close();

   debug(0,"****************\nCreated avg_cmode.dat in current directory for further use\n**************");

  return ok;
}


Long_t Det_LumiGEM::dumpPedestals()
{
  if (doSubtractped)
    debug(0,"***************\nWarning: Pedestals have been subtracted: Exported Pedestals are difference only!\n**************\n");

  ofstream myfile;
  myfile.open("bin_2_bin_pedestals.dat");

  // ofstream outf("ped.xml");
  //int id=0;
  for (int t=0;t<2;t++)
    for (int i=0;i<3;i++)
      {
	//	TProfile  *xprof=h2adcspec_cmode_nopk_x[t][i]->ProfileX();
	//	TProfile  *yprof=h2adcspec_cmode_nopk_y[t][i]->ProfileX();
	for (int k=0;k<250;k++)
	  {
	    // find average of cm and peak suppressed spectra histogram:
	    // if (((int)xprof->GetBinContent(k+1))!=0)
	    //  outf<<"<PerChannelPed id="<<'"'<<id<<'"'<<">"<< t<<","<<i<<","<<k<<",0,"<<(int) xprof->GetBinContent(k+1)<<"</PerChannelPed>"<<std::endl;
	    // id++;
	    // if (((int)yprof->GetBinContent(k+1))!=0)
	    //   outf<<"<PerChannelPed id="<<'"'<<id<<'"'<<">"<< t<<","<<i<<","<<k<<",1,"<<(int) yprof->GetBinContent(k+1)<<"</PerChannelPed>"<<std::endl;
	    // id++;
	   
	    // get the average pedestals on each bin
	    if (gettotpedxentries[i][k]>0) getavgpedx[i][k]=gettotpedx[i][k]/gettotpedxentries[i][k];
	    else getavgpedx[i][k]=10000;
	    if ((getavgpedx[i][k]==1)||(getavgpedx[i][k]==0)) getavgpedx[i][k]=10000;
	    if (gettotpedyentries[i][k]>0) getavgpedy[i][k]=gettotpedy[i][k]/gettotpedyentries[i][k];
	    else getavgpedy[i][k]=10000;
	    if ((getavgpedy[i][k]==1)||(getavgpedy[i][k]==0)) getavgpedy[i][k]=10000;
	    myfile <<i<<"\t"<<k<<"\t"<<getavgpedx[i][k]<<"\t"<<getavgpedy[i][k]<< endl;
	  }    
      }
  myfile.close();
  //      outf.close();

  //  debug(0,"****************\nCreated bin_2_bin_pedestals.txt in current directory. Please paste contents into gem init xml with appropriate time tag\n**************");
  debug(0,"****************\nCreated bin_2_bin_pedestals.dat in current directory. \n**************");

  return ok;
}

//////////////////////////////////////////////////////////////////////////////////////////

Long_t Det_LumiGEM::done_APVcalib()
{
   if (doAPVcalib)
     debug(0,"***************\nWarning: If you really don't want to perform APV channel-to-channel gain calibrations, then please deactivate the 'doAPVcalib' \n**************\n");

   ofstream myxcalibfile,myycalibfile;
  myxcalibfile.open("do_APV_Xcalib.dat");
 myycalibfile.open("do_APV_Ycalib.dat");

double avgmaxADC_x[3][250],avgmaxADC_y[3][250];
double xmaxdata[3][250],ymaxdata[3][250];


  for (int t=1;t<2;t++)
    for (int i=0;i<3;i++)
      {


 int count_x,count_y;
 count_x=0;
 count_y=0;
 int index_x[250],index_y[250];

 for (int k=0;k<250;k++)
   {
	//Get the mean of maximum ADCs on each APV channel (After common mode and Pedestal subtraction)	   
     if ((gettotx_adc_e[i][k]>0)){
       avgmaxADC_x[i][k]=gettotx_adc[i][k]/gettotx_adc_e[i][k];
       count_x=count_x+1;
       index_x[count_x]=k;
       xmaxdata[i][k]=avgmaxADC_x[i][k];
       //printf(" get avg. max. X ADC %d %d %d %d   %d %10.2lf\n", t,i, k,count_x, gettotx_adc_e[i][k], avgmaxADC_x[i][k]);
     }
	    //  else avgmaxADC_x[i][k]=-10000;
     else xmaxdata[i][k]=-100000;

     if ((gettoty_adc_e[i][k]>0)) {
       avgmaxADC_y[i][k]=gettoty_adc[i][k]/gettoty_adc_e[i][k];
	      //  if (avgmaxADC_y[i][k]>1000) {
       count_y=count_y+1;
       index_y[count_y]=k;
		  //  ymaxdata[i][k]=avgmaxADC_y[i][k];
       ymaxdata[i][k]=avgmaxADC_y[i][k];
		  //	};
     }
     else ymaxdata[i][k]=-100000;
	    //	printf(" get avg. max. X ADC %d %d %d %d %10.2lf %d %10.2lf  \n", t,i, k,count_x,gettotx_adc[i][k],gettotx_adc_e[i][k],avgmaxADC_x[i][k]);

	    //printf(" get avg. max. X ADC %d %d %d %d %d  %10.2lf %d %d %d %10.2lf %d\n", t,i, k, gettotx_adc[i][k],gettotx_adc_e[i][k],avgmaxADC_x[i][k],count_x[i], gettoty_adc[i][k],gettoty_adc_e[i][k],avgmaxADC_y[i][k],count_y[i]);
	   
   }; 

	double index[count_x];
	double xdata[count_x];
	for (int n=1;n<count_x+1;n++)
	  {
	    index[n] = index_x[n];
	    xdata[n]=avgmaxADC_x[i][index_x[n]];
	    //	    xdata[n]=avgmaxADC_x[i][index_x[n]];	
	    //	printf(" get avg. max. X ADC %d %d %d %d %10.2lf %10.2lf %10.2lf\n", t,i,n,index_x[n],index[n],avgmaxADC_x[i][index_x[n]],xdata[n]);
	    myxcalibfile <<t<<"\t"<<i<<"\t"<<n<<"\t"<<index[n]<<"\t"<<xdata[n]<< endl;
	  };

	double yindex[count_y];
	double ydata[count_y];
	for (int ny=1;ny<count_y+1;ny++)
	  {
	    yindex[ny] = index_y[ny];
	    ydata[ny]=avgmaxADC_y[i][index_y[ny]];
	    //	    ydata[ny]=avgmaxADC_y[i][index_y[ny]];	
		//	printf(" get avg. max. X ADC %d %d %d %d %10.2lf %10.2lf %10.2lf\n", t,i,n,index_x[n],index[n],avgmaxADC_x[i][index_x[n]],xdata[n]);
	    myycalibfile <<t<<"\t"<<i<<"\t"<<ny<<"\t"<<yindex[ny]<<"\t"<<ydata[ny]<< endl;
	  };


	//	TGraph *gtmp  = new TGraph(count_x, index, xdata);
      }    
    myxcalibfile.close();
    myycalibfile.close();

    debug(0,"****************\nCreated do_APV_X(Y)calib.dat in the current directory. Use it for linear fit and do the gain calibrations accordingly.\n**************");

  return ok;
}
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////


Long_t Det_LumiGEM::cmdline(char *cmd)
{
  char *aux=NULL;
  cout << "LumiGEM: Got commandline: >" << cmd << "<" << endl;
  ///////////////////////////////////////////////////////
  // check for verbosity:
  if (strstr(cmd, "-v"))
    verbose=1;
  if (strstr(cmd, "-vv"))
    verbose=2;
  if (strstr(cmd, "-vvv"))
    verbose=3;
  printf(" verbosity %d\n", verbose);
  ///////////////////////////////////////////////////////
  // check if only DetectorFlag should be processed:
  if (strstr(cmd, "--detectorflagonly"))
    ProcessDetectorFlagOnly = true;
  ///////////////////////////////////////////////////////

  return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

void Det_LumiGEM::cleanup()
{
  cout << "LumiGEM: deleting GEM objects..." << endl;
  
  delete[] xdat;
  delete[] ydat;
  delete[] xdatraw;
  delete[] ydatraw;

  delete gemo;
  //  delete[] hitfinder;
  //  delete[] LumiGUI;
  delete[] tmpdat;

  for (int t=0; t<2; t++)  // two telescopes
    for (int i=0; i<3; i++)// three GEMs per telescope
      {
	delete GEM[t][i];
	//	delete H_hitmap2d[t][i];
	for (int j=0; j<3; j++)
	  {
	    //   delete H_XvsX[t][i][j];
	    //  delete H_YvsY[t][i][j];
	  };
      };

dattotx_nopk_ent.clear();
dattoty_nopk_ent.clear();

gettotpedx.clear();
gettotpedy.clear();
gettotpedxentries.clear();
gettotpedyentries.clear();
totent.clear();
//totampx.clear();
//totampy.clear();
gettotx_adc.clear();
gettoty_adc.clear();
gettotx_adc_e.clear();
gettoty_adc_e.clear();


//avgmaxADC_x.clear();
//avgmaxADC_y.clear();

}


extern "C"{
  Plugin *factory(TTree *in, TTree *out, TFile *inf_, TFile *outf_, TObject *p)
  {
    return (Plugin *) new Det_LumiGEM(in, out, inf_, outf_, p);
  }
}


ClassImp(Det_LumiGEM);
